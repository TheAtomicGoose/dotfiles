#include <stdio.h>

#include <X11/Xlib.h>

#include <GLES2/gl2.h>
#include <EGL/egl.h>

Display *x11Display;
Window window;
EGLDisplay eglDisplay;
EGLContext eglContext;
EGLSurface eglSurface;

// Vertex shader source
const GLchar* vertexSource =
    "#version 150 core\n"
    "in vec2 position;"
    "void main() {"
    "   gl_Position = vec4(position, 0.0, 1.0);"
    "}";

// Fragment shader source
const GLchar* fragmentSource =
    "#version 150 core\n"
    "out vec4 outColor;"
    "void main() {"
    "   outcolor = vec4(1.0, 1.0, 1.0, 1.0);"
    "}";

void init() {
    // Put your OpenGL initialization code here.

    // Creating a Vertex Array Object
    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    // Create a Vertex Buffer Object and copy the data to it
    GLuint vbo;
    glGenBuffers(1, &vbo);
    GLfloat vertices[] = {
         0.0f,  0.5f, // Vertex 1 (X, Y)
         0.5f, -0.5f, // Vertex 2 (X, Y)
        -0.5f, -0.5f  // Vertex 3 (X, Y)    
    };

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // Create and compile the vertex shader
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexSource, NULL);
    glCompileShader(vertexShader);

    // Create and compile the vertex shader
    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentSource, NULL);
    glCompileShader(fragmentShader);

    // Link the vertex and fragment shader into a shader program
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    glUseProgram(shaderProgram);

    // Specify the layout of the vertex data
    GLint posAtrrib = glGetAttribLocation(shaderProgram, "position");
    glVertexAttribPointer(posAtrrib, 2, GL_FLOAT, GL_FALSE, 0, 0); 
    glEnableVertexAttribArray(posAtrrib);

    return glGetError();
}

void display() {
    // Put your OpenGL display code here.
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    
    // Drawing the triangle
    glDrawArrays(GL_TRIANGLES, 0, 3);
}

void cleanup() {
    // Put your OpenGL cleanup code here.
}

int main(int argc, char* argv[]) { 
    // Don't worry about the code in here!
    // You only need to modify init(), display(), and cleanup()
    // (and any additional variables you need).

    // X11 initialization
    x11Display = XOpenDisplay(NULL);
    if (!x11Display) {
        printf("Could not open X11 display.");
        return 1;
    }
    
    // X11 Window
    XSetWindowAttributes x11Attr;
    x11Attr.event_mask = ExposureMask | StructureNotifyMask;
    Screen* defaultScreen = XDefaultScreenOfDisplay(x11Display);
    x11Attr.colormap = DefaultColormapOfScreen(defaultScreen);
    x11Attr.override_redirect = 0;
    window = XCreateWindow(x11Display, DefaultRootWindow(x11Display),
                           0, 0, 800, 600, 0,
                           CopyFromParent, InputOutput, CopyFromParent,
                           (CWColormap|CWEventMask|CWOverrideRedirect),
                           &x11Attr);
    XMapWindow(x11Display, window);
    XStoreName(x11Display, window, "Intro to OpenGL");
    Atom wmDeleteWindow = XInternAtom(x11Display, "WM_DELETE_WINDOW", 0);
    XSetWMProtocols(x11Display, window, &wmDeleteWindow, 1);

    // EGL initialization
    eglDisplay = eglGetDisplay((EGLNativeDisplayType)x11Display);
    if (!eglInitialize(eglDisplay, NULL, NULL)) {
        printf("Could not initialize EGL.");
    }

    EGLConfig eglConfig;
    EGLint eglAttrs[] = {
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_DEPTH_SIZE, 16,
        EGL_NONE
    };
    EGLint matches;
    if (!eglChooseConfig(eglDisplay, eglAttrs, &eglConfig, 1, &matches) ||
        !matches) {
        printf("Could not choose EGL config.");
        return 1;
    }

    eglBindAPI(EGL_OPENGL_ES_API);
    
    EGLint ctxAttrs[] = {
        EGL_CONTEXT_CLIENT_VERSION, 2,
        EGL_NONE
    };
    eglContext = eglCreateContext(eglDisplay, eglConfig, EGL_NO_CONTEXT,
                                  ctxAttrs);
    if (eglContext == EGL_NO_CONTEXT) {
        printf("Could not create EGL context.");   
        return 1;
    }

    eglSurface = eglCreateWindowSurface(eglDisplay, eglConfig,
                                        window, NULL);

    eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext);

    // OpenGL init and render loop
    init();

    XEvent event;
    int closed = 0;

    while (!closed) {
        while (XPending(x11Display)) {
            XNextEvent(x11Display, &event);
            if (event.type == ClientMessage &&
                event.xclient.data.l[0] == wmDeleteWindow) {
                closed = 1;
            }
        }
        display();
        eglSwapBuffers(eglDisplay, eglSurface);
    }

    cleanup();

    // EGL cleanup
    eglDestroySurface(eglDisplay, eglSurface);
    eglDestroyContext(eglDisplay, eglContext);
    eglTerminate(eglDisplay);

    return 0;
}
